Option Explicit

Sub ImportiereRohdatenFinal()
    Dim wbDash As Workbook
    Dim wbData As Workbook
    Dim wsZuweisung As Worksheet
    Dim wsZiel As Worksheet
    Dim wsData As Worksheet
    Dim wsKategorien As Worksheet
    Dim rngFound As Range
    
    Dim lLetzteZeileZuweisung As Long
    Dim lLetzteZeileData As Long
    
    Dim i As Long, j As Long
    
    Dim rawKey As String
    Dim rawVorgang As String
    Dim rawHeader As String
    Dim rawValue As Variant
    Dim strZielblattName As String
    Dim lZielzeile As Long
    
    Dim dictHeaders As Object
    Dim dictStartZeilen As Object ' Für jede Zielblattname die ermittelte Startzeile
    Dim dictKategorien As Object
    
    Dim upperHeader As String
    Dim zielSpalte As Long
    
    Dim englVal As Variant
    Dim rawValL As Variant
    
    ' Hier gehen wir davon aus, dass "Kategorien" usw. bereits vorhanden sind, 
    ' da wir nur auf den vorherigen Stand zurück wollen. Bei Bedarf anpassen.
    
    Set wbDash = ThisWorkbook
    Set wsZuweisung = wbDash.Worksheets("Zuweisung")
    
    ' Rohdaten öffnen (Pfad anpassen!)
    Set wbData = Workbooks.Open("C:\Pfad\zu\Leaptree_Data.xlsx")
    Set wsData = wbData.Worksheets(1)
    
    lLetzteZeileZuweisung = wsZuweisung.Cells(wsZuweisung.Rows.Count, 2).End(xlUp).Row
    lLetzteZeileData = wsData.Cells(wsData.Rows.Count, 1).End(xlUp).Row
    
    Set dictHeaders = CreateObject("Scripting.Dictionary")
    Set dictStartZeilen = CreateObject("Scripting.Dictionary")
    
    '------------------------------------------------------------
    ' Keine Änderungen an der Übersetzungslogik usw., da "zurück"
    ' Wenn nötig, hier den alten Zustand beibehalten.
    '------------------------------------------------------------
    
    ' Wir gehen davon aus, dass wir wie vorher arbeiten.
    ' Die Übersetzungs- und Headerlogik bleibt unverändert.
    ' Wenn Sie die Kategorientabelle weiterhin nutzen wollen,
    ' können Sie hier analog zum vorherigen Code dictKategorien füllen.
    ' Hier ist nur fokussiert auf die Startzeilen-Logik.
    
    For i = 2 To lLetzteZeileData
        rawKey = wsData.Cells(i, 1).Value      ' Rohdaten Spalte A
        rawVorgang = wsData.Cells(i, 2).Value  ' Rohdaten Spalte B
        rawHeader = wsData.Cells(i, 10).Value  ' Rohdaten Spalte J (Headername)
        
        ' Schlüssel in Zuweisung suchen
        Set rngFound = wsZuweisung.Columns(2).Find(What:=rawKey, LookAt:=xlWhole)
        If Not rngFound Is Nothing Then
            strZielblattName = rngFound.Offset(0, 1).Value
            
            On Error Resume Next
            Set wsZiel = wbDash.Worksheets(strZielblattName)
            On Error GoTo 0
            
            If wsZiel Is Nothing Then GoTo NächsterDatensatz
            
            ' Headers des Zielblatts einlesen, falls noch nicht geschehen
            If dictHeaders.Count = 0 Then
                Dim lastCol As Long
                lastCol = wsZiel.Cells(12, wsZiel.Columns.Count).End(xlToLeft).Column
                For j = 1 To lastCol
                    If Not dictHeaders.Exists(CStr(wsZiel.Cells(12, j).Value)) Then
                        dictHeaders(CStr(wsZiel.Cells(12, j).Value)) = j
                    End If
                Next j
            End If
            
            ' Einmalig pro Blatt Startzeile bestimmen nach neuer Logik
            Dim startZeile As Long
            If Not dictStartZeilen.Exists(strZielblattName) Then
                ' Neue Logik:
                ' 1. Ermittel Datum aus Rohdaten (Spalte D) vom ersten relevanten Datensatz
                Dim rawDate As Date
                rawDate = wsData.Cells(i, 4).Value
                
                ' Wenn Montag, dann 3 Tage zurück (Freitag), sonst Datum so lassen.
                ' (Annahme: der User meinte vorher: wenn Montag dann Freitag -3, 
                ' jetzt nur 'Wenn Montag nimm vergangenen Freitag')
                If Weekday(rawDate) = vbMonday Then
                    rawDate = rawDate - 3
                End If
                
                ' Kalenderwoche bestimmen
                Dim kw As Long
                kw = GetKalenderwoche(rawDate)
                
                ' Nach "KW X" suchen
                Dim rngKW As Range
                Set rngKW = wsZiel.Cells.Find(What:="KW " & kw, LookAt:=xlPart)
                If rngKW Is Nothing Then
                    ' Falls nicht gefunden, Fehlerbehandlung
                    MsgBox "KW " & kw & " nicht gefunden in " & wsZiel.Name, vbExclamation
                    GoTo NächsterDatensatz
                End If
                
                ' 3 Zellen runter von rngKW
                Dim startCheckCell As Range
                Set startCheckCell = rngKW.Offset(3, 0)
                
                ' Jetzt +30er Schritte prüfen
                startZeile = startCheckCell.Row
                Do While wsZiel.Cells(startZeile, 1).Value <> ""
                    startZeile = startZeile + 30
                Loop
                
                dictStartZeilen(strZielblattName) = startZeile
            Else
                startZeile = dictStartZeilen(strZielblattName)
            End If
            
            ' Vorgangszeile finden oder erstellen
            Dim rngVorgang As Range
            Set rngVorgang = wsZiel.Columns(1).Find(What:=rawVorgang, LookAt:=xlWhole)
            If rngVorgang Is Nothing Then
                ' Neuen Eintrag in startZeile
                lZielzeile = startZeile
                wsZiel.Cells(lZielzeile, 1).Value = rawVorgang
                wsZiel.Cells(lZielzeile, 2).Value = wsData.Cells(i, 3).Value
                ' Startzeile um 1 erhöhen
                dictStartZeilen(strZielblattName) = startZeile + 1
            Else
                lZielzeile = rngVorgang.Row
            End If
            
            ' Header abhängige Werte
            If dictHeaders.Exists(rawHeader) Then
                zielSpalte = dictHeaders(rawHeader)
                rawValue = wsData.Cells(i, 12).Value
                wsZiel.Cells(lZielzeile, zielSpalte).Value = rawValue
            End If
            
        End If
NächsterDatensatz:
        Set wsZiel = Nothing
    Next i
    
    wbData.Close False
    MsgBox "Import abgeschlossen!"
End Sub

Function GetKalenderwoche(datum As Date) As Long
    ' Ein einfaches Beispiel zur Berechnung der KW:
    ' Hier nutzen wir die ISO-Kalenderwoche.
    ' Diese Beispielimplementierung nutzt VBA 2-digit year rules nicht, 
    ' sondern ein einfaches Konstrukt:
    ' KW = (datum - Startwert)/7 + 1 mit Berücksichtigung Montag als Wochenstart
    ' Für eine korrekte ISO-KW Berechnung ist ggf. eine komplexere Funktion nötig.
    
    ' Vereinfachte ISO KW-Berechnung:
    Dim WeekNum As Long
    ' Montag als erster Wochentag
    ' ISO 8601: Die KW des Jahres ist diejenige, 
    ' die den ersten Donnerstag des Jahres enthält.
    ' Hier zur Vereinfachung eine VBA-Funktion:
    
    ' Hinweis: Diese einfache Funktion funktioniert nicht für alle Jahre ISO-konform.
    ' Für eine vollständige ISO-KW Berechnung bitte eine erprobte Funktion nutzen.
    ' Beispiel einer einfachen Herangehensweise:
    
    WeekNum = DatePart("ww", datum, vbMonday, vbFirstFourDays)
    GetKalenderwoche = WeekNum
End Function
