Option Explicit

Sub ImportiereRohdatenFinal()
    Dim wbDash As Workbook
    Dim wbData As Workbook
    Dim wsZuweisung As Worksheet
    Dim wsZiel As Worksheet
    Dim wsData As Worksheet
    Dim wsKategorien As Worksheet
    Dim rngFound As Range

    Dim lLetzteZeileZuweisung As Long
    Dim lLetzteZeileData As Long
    Dim lLetzteZeileKatA As Long

    Dim i As Long, j As Long

    Dim rawKey As String
    Dim rawVorgang As String
    Dim rawHeader As String
    Dim rawValue As Variant
    Dim strZielblattName As String
    Dim lZielzeile As Long

    Dim dictHeaders As Object
    Dim dictStartZeilen As Object
    Dim dictKategorien As Object

    Dim upperHeader As String
    Dim zielSpalte As Long
    Dim englischerText As String
    Dim deutscherText As String

    Dim englVal As Variant
    Dim rawValL As Variant

    Dim rawDate As Variant ' Verwenden Sie Variant für Flexibilität
    Dim adjustedDate As Date
    Dim currentKW As String

    ' Setzen der Arbeitsmappen und Arbeitsblätter
    Set wbDash = ThisWorkbook
    Set wsZuweisung = wbDash.Worksheets("Zuweisung")
    Set wsKategorien = wbDash.Worksheets("Kategorien")

    ' Rohdaten öffnen (Pfad anpassen!)
    On Error GoTo Fehlerbehandlung
    Set wbData = Workbooks.Open("C:\Pfad\zu\Leaptree_Data.xlsx") ' Passen Sie den Pfad an
    On Error GoTo 0
    Set wsData = wbData.Worksheets(1)

    ' Letzte Zeilen ermitteln
    lLetzteZeileZuweisung = wsZuweisung.Cells(wsZuweisung.Rows.Count, 2).End(xlUp).Row
    lLetzteZeileData = wsData.Cells(wsData.Rows.Count, 1).End(xlUp).Row

    ' Dictionaries initialisieren
    Set dictHeaders = CreateObject("Scripting.Dictionary")       ' Dictionary für Headers pro Zielblatt
    Set dictStartZeilen = CreateObject("Scripting.Dictionary")  ' Dictionary für Startzeilen pro Zielblatt
    Set dictKategorien = CreateObject("Scripting.Dictionary")    ' Dictionary für Kategorienübersetzung

    ' Kategorien einlesen (Englisch -> Deutsch)
    lLetzteZeileKatA = wsKategorien.Cells(wsKategorien.Rows.Count, 1).End(xlUp).Row
    For i = 2 To lLetzteZeileKatA
        If Not IsEmpty(wsKategorien.Cells(i, 1)) Then
            englischerText = Trim(CStr(wsKategorien.Cells(i, 1).Value))
            deutscherText = Trim(CStr(wsKategorien.Cells(i, 2).Value))
            If Not dictKategorien.Exists(englischerText) Then
                dictKategorien(englischerText) = deutscherText
            End If
        End If
    Next i

    ' Datenimport starten
    For i = 2 To lLetzteZeileData
        rawKey = Trim(CStr(wsData.Cells(i, 1).Value))      ' Rohdaten Spalte A - Schlüssel
        rawVorgang = Trim(CStr(wsData.Cells(i, 2).Value))  ' Rohdaten Spalte B - Vorgangsnummer
        rawHeader = Trim(CStr(wsData.Cells(i, 10).Value))  ' Rohdaten Spalte J - Headername
        rawDate = wsData.Cells(i, 4).Value                ' Rohdaten Spalte D - Datum

        ' Schlüssel in Zuweisung suchen
        Set rngFound = wsZuweisung.Columns(2).Find(What:=rawKey, LookAt:=xlWhole, LookIn:=xlValues, MatchCase:=False)
        If Not rngFound Is Nothing Then
            strZielblattName = Trim(CStr(rngFound.Offset(0, 1).Value))

            ' Zielblatt referenzieren
            On Error Resume Next
            Set wsZiel = wbDash.Worksheets(strZielblattName)
            On Error GoTo 0

            If wsZiel Is Nothing Then
                ' Zielblatt nicht gefunden, nächsten Datensatz
                GoTo NächsterDatensatz
            End If

            ' Prüfung: Datum in Rohdaten (Spalte D) muss gleich Datum in Spalte V sein
            Dim datumSpalteV As Variant
            datumSpalteV = wsZiel.Cells(wsZiel.Rows.Count, 22).End(xlUp).Value ' Datum aus der letzten Zeile der Spalte V

            If IsDate(rawDate) And IsDate(datumSpalteV) Then
                If CDate(rawDate) <> CDate(datumSpalteV) Then
                    Debug.Print "Datum stimmt nicht überein: Rohdaten " & rawDate & ", Zielblatt " & datumSpalteV
                    GoTo NächsterDatensatz
                End If
            Else
                Debug.Print "Ungültiges Datum in Rohdaten oder Zielblatt: " & rawDate & " / " & datumSpalteV
                GoTo NächsterDatensatz
            End If

            ' Headers des Zielblatts einlesen, falls noch nicht geschehen
            If Not dictHeaders.Exists(strZielblattName) Then
                Set dictHeaders(strZielblattName) = CreateObject("Scripting.Dictionary")
                For j = 3 To 17 ' Spalten C bis Q
                    If Not IsEmpty(wsZiel.Cells(12, j).Value) Then
                        upperHeader = UCase(Trim(CStr(wsZiel.Cells(12, j).Value)))
                        If Not dictHeaders(strZielblattName).Exists(upperHeader) Then
                            dictHeaders(strZielblattName)(upperHeader) = j
                        End If
                    End If
                Next j
            End If

            ' Übersetzung der Werte in Spalte L (z. B. Ja/Nein/N/A)
            rawValL = Trim(CStr(wsData.Cells(i, 12).Value)) ' Rohdaten Spalte L

            Select Case UCase(rawValL)
                Case "JA"
                    rawValL = "j"
                Case "NEIN"
                    rawValL = "n"
                Case "N/A"
                    rawValL = ""   ' Leer lassen
                Case "TEILWEISE"
                    rawValL = "t"
            End Select

            ' Werte basierend auf Header in Zielblatt einfügen
            upperHeader = UCase(Trim(CStr(rawHeader)))
            If dictHeaders(strZielblattName).Exists(upperHeader) Then
                zielSpalte = dictHeaders(strZielblattName)(upperHeader)
                wsZiel.Cells(wsZiel.Rows.Count, zielSpalte).End(xlUp).Offset(1, 0).Value = rawValL
                Debug.Print "Wert " & rawValL & " in Spalte " & zielSpalte & " eingefügt."
            Else
                Debug.Print "Header " & upperHeader & " nicht gefunden."
            End If
        End If
NächsterDatensatz:
        Set wsZiel = Nothing
    Next i

    wbData.Close False
    MsgBox "Import abgeschlossen!"
    Exit Sub

Fehlerbehandlung:
    MsgBox "Ein Fehler ist aufgetreten: " & Err.Description, vbCritical
    On Error Resume Next
    wbData.Close False
End Sub
