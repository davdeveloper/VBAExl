Option Explicit

Sub ImportiereRohdatenFinal()
    Dim wbDash As Workbook
    Dim wbData As Workbook
    Dim wsZuweisung As Worksheet
    Dim wsZiel As Worksheet
    Dim wsData As Worksheet
    Dim wsKategorien As Worksheet
    Dim rngFound As Range
    
    Dim lLetzteZeileZuweisung As Long
    Dim lLetzteZeileData As Long
    Dim lLetzteZeileKatA As Long
    
    Dim i As Long, j As Long
    
    Dim rawKey As String
    Dim rawVorgang As String
    Dim rawHeader As String
    Dim rawValue As Variant
    Dim strZielblattName As String
    Dim lZielzeile As Long
    
    Dim dictHeaders As Object
    Dim dictStartZeilen As Object
    Dim dictKategorien As Object
    
    Dim upperHeader As String
    Dim zielSpalte As Long
    Dim englischerText As String
    Dim deutscherText As String
    
    Dim englVal As Variant
    Dim rawValL As Variant
    
    Dim rawDate As Variant ' Verwenden Sie Variant für Flexibilität
    Dim adjustedDate As Date
    Dim currentKW As String
    
    ' Setzen der Arbeitsmappen und Arbeitsblätter
    Set wbDash = ThisWorkbook
    Set wsZuweisung = wbDash.Worksheets("Zuweisung")
    Set wsKategorien = wbDash.Worksheets("Kategorien")
    
    ' Rohdaten öffnen (Pfad anpassen!)
    On Error GoTo Fehlerbehandlung
    Set wbData = Workbooks.Open("C:\Pfad\zu\Leaptree_Data.xlsx") ' Passen Sie den Pfad an
    On Error GoTo 0
    Set wsData = wbData.Worksheets(1)
    
    ' Letzte Zeilen ermitteln
    lLetzteZeileZuweisung = wsZuweisung.Cells(wsZuweisung.Rows.Count, 2).End(xlUp).Row
    lLetzteZeileData = wsData.Cells(wsData.Rows.Count, 1).End(xlUp).Row
    
    ' Dictionaries initialisieren
    Set dictHeaders = CreateObject("Scripting.Dictionary")       ' Dictionary für Headers pro Zielblatt
    Set dictStartZeilen = CreateObject("Scripting.Dictionary")  ' Dictionary für Startzeilen pro Zielblatt
    Set dictKategorien = CreateObject("Scripting.Dictionary")    ' Dictionary für Kategorienübersetzung
    
    ' Kategorien einlesen (Englisch -> Deutsch)
    lLetzteZeileKatA = wsKategorien.Cells(wsKategorien.Rows.Count, 1).End(xlUp).Row
    For i = 2 To lLetzteZeileKatA
        If Not IsEmpty(wsKategorien.Cells(i, 1)) Then
            englischerText = Trim(CStr(wsKategorien.Cells(i, 1).Value))
            deutscherText = Trim(CStr(wsKategorien.Cells(i, 2).Value))
            If Not dictKategorien.Exists(englischerText) Then
                dictKategorien(englischerText) = deutscherText
            End If
        End If
    Next i
    
    ' Datenimport starten
    For i = 2 To lLetzteZeileData
        rawKey = Trim(CStr(wsData.Cells(i, 1).Value))      ' Rohdaten Spalte A - Schlüssel
        rawVorgang = Trim(CStr(wsData.Cells(i, 2).Value))  ' Rohdaten Spalte B - Vorgangsnummer
        rawHeader = Trim(CStr(wsData.Cells(i, 10).Value))  ' Rohdaten Spalte J - Headername
        
        ' Schlüssel in Zuweisung suchen
        Set rngFound = wsZuweisung.Columns(2).Find(What:=rawKey, LookAt:=xlWhole, LookIn:=xlValues, MatchCase:=False)
        If Not rngFound Is Nothing Then
            strZielblattName = Trim(CStr(rngFound.Offset(0, 1).Value))
            
            ' Zielblatt referenzieren
            On Error Resume Next
            Set wsZiel = wbDash.Worksheets(strZielblattName)
            On Error GoTo 0
            
            If wsZiel Is Nothing Then
                ' Zielblatt nicht gefunden, nächsten Datensatz
                GoTo NächsterDatensatz
            End If
            
            ' Headers des Zielblatts einlesen, falls noch nicht geschehen
            If Not dictHeaders.Exists(strZielblattName) Then
                Set dictHeaders(strZielblattName) = CreateObject("Scripting.Dictionary")
                For j = 3 To 17 ' Spalten C bis Q
                    If Not IsEmpty(wsZiel.Cells(12, j).Value) Then
                        upperHeader = UCase(Trim(CStr(wsZiel.Cells(12, j).Value)))
                        If Not dictHeaders(strZielblattName).Exists(upperHeader) Then
                            dictHeaders(strZielblattName)(upperHeader) = j
                        End If
                    End If
                Next j
            End If
            
            ' Einmalig pro Blatt Startzeile bestimmen
            Dim startZeile As Long
            If Not dictStartZeilen.Exists(strZielblattName) Then
                ' Bestimmen der Startzeile basierend auf der aktuellen KW
                rawDate = wsData.Cells(i, 4).Value ' Rohdaten Spalte D
                If IsDate(rawDate) Then
                    rawDate = CDate(rawDate)
                Else
                    rawDate = Date ' Fallback auf aktuelles Datum, falls ungültig
                    Debug.Print "Ungültiges Datum in Zeile " & i & ", Spalte D. Fallback auf aktuelles Datum: " & rawDate
                End If
                
                ' Wenn das Datum ein Montag ist, nimm den vergangenen Freitag
                If Weekday(rawDate, vbMonday) = vbMonday Then
                    adjustedDate = rawDate - 3
                Else
                    adjustedDate = rawDate - 1
                End If
                
                ' Kalenderwoche berechnen mit führender Null
                currentKW = "KW " & Format(GetKalenderwoche(adjustedDate), "00")
                
                ' Debugging-Ausgabe
                Debug.Print "Zeile " & i & ": rawDate = " & rawDate & ", adjustedDate = " & adjustedDate & ", currentKW = " & currentKW
                
                ' Nach "KW xx" in mehreren Spalten suchen mittels Hilfsfunktion
                Set rngFound = FindKWInColumns(wsZiel, currentKW, Array("A", "B", "C", "D", "E")) ' Passen Sie die Spalten nach Bedarf an
                
                If rngFound Is Nothing Then
                    ' Falls nicht gefunden, Debugging-Ausgabe aller vorhandenen KW-Werte in den durchsuchten Spalten
                    Dim allKWs As String
                    allKWs = ""
                    Dim col As Variant
                    Dim lastRow As Long
                    For Each col In Array("A", "B", "C", "D", "E") ' Passen Sie die Spalten nach Bedarf an
                        lastRow = wsZiel.Cells(wsZiel.Rows.Count, col).End(xlUp).Row
                        For j = 1 To lastRow
                            If Left(Trim(UCase(wsZiel.Cells(j, col).Value)), 2) = "KW" Then
                                allKWs = allKWs & wsZiel.Cells(j, col).Value & ", "
                            End If
                        Next j
                    Next col
                    MsgBox currentKW & " nicht in den durchsuchten Spalten des Arbeitsblatts '" & wsZiel.Name & "' gefunden." & vbCrLf & _
                           "Vorhandene Kalenderwochen in den durchsuchten Spalten: " & allKWs, vbExclamation
                    dictStartZeilen(strZielblattName) = 0
                    GoTo NächsterDatensatz
                Else
                    ' Zeile anzeigen, wo "KW xx" gefunden wurde
                    MsgBox "Aktuelle Kalenderwoche '" & currentKW & "' gefunden in Zelle: " & rngFound.Address & " (Spalte " & rngFound.Column & ")", vbInformation
                End If
                
                ' *** Änderung: Gehe 8 Zeilen nach unten von der KW-Zelle ***
                startZeile = rngFound.Row + 8
                
                ' *** Prüfen, ob die Zelle leer ist. Wenn nicht, zur nächsten freien Zelle gehen ***
                If wsZiel.Cells(startZeile, rngFound.Column).Value <> "" Then
                    Debug.Print "Zelle " & wsZiel.Cells(startZeile, rngFound.Column).Address & " ist nicht leer. Suche nach der nächsten freien Zelle."
                    Do While wsZiel.Cells(startZeile, rngFound.Column).Value <> ""
                        Debug.Print "Zelle " & wsZiel.Cells(startZeile, rngFound.Column).Address & " ist nicht leer. Gehe eine Zeile weiter."
                        startZeile = startZeile + 1
                        ' Optional: Abbruchbedingung, um eine Endlosschleife zu vermeiden
                        If startZeile > wsZiel.Rows.Count Then
                            MsgBox "Keine freie Zelle nach KW " & currentKW & " gefunden.", vbCritical
                            startZeile = 0
                            Exit Do
                        End If
                    Loop
                Else
                    Debug.Print "Zelle " & wsZiel.Cells(startZeile, rngFound.Column).Address & " ist leer. Verwende diese Zeile."
                End If
                
                ' Debugging-Ausgabe der gefundenen Startzeile
                If startZeile > 0 Then
                    Debug.Print "Gefundene Startzeile für das Einfügen: " & startZeile
                End If
                
                ' Startzeile festlegen und speichern
                dictStartZeilen(strZielblattName) = startZeile
            Else
                ' Schlüssel nicht gefunden in Zuweisung, nächsten Datensatz
                GoTo NächsterDatensatz
            End If
            
            ' Vorgangszeile setzen direkt auf startZeile (ohne Überprüfung auf Duplikate)
            lZielzeile = dictStartZeilen(strZielblattName)
            
            ' Daten in die Zielzeile einfügen
            ' Übersetzung der Spalte C (Englisch -> Deutsch)
            englVal = Trim(CStr(wsData.Cells(i, 3).Value))
            If dictKategorien.Exists(englVal) Then
                wsZiel.Cells(lZielzeile, 2).Value = dictKategorien(englVal) ' Deutscher Text
            Else
                wsZiel.Cells(lZielzeile, 2).Value = englVal ' Unverändert, falls kein Mapping
            End If
            
            ' Vorgangsnummer in Spalte A
            wsZiel.Cells(lZielzeile, 1).Value = rawVorgang
            
            ' Spalte V (22) = Rohdaten Spalte D (4)
            wsZiel.Cells(lZielzeile, 22).Value = rawDate
            
            ' Spalte W (23) = Rohdaten Spalte E (5)
            wsZiel.Cells(lZielzeile, 23).Value = wsData.Cells(i, 5).Value
            
            ' Spalte U (21):
            ' Immer einen Tag zurück, außer wenn dieser Tag ein Sonntag ist, dann Freitag vorher
            If Weekday(rawDate - 1, vbMonday) = vbSunday Then
                wsZiel.Cells(lZielzeile, 21).Value = rawDate - 3
                Debug.Print "Zeile " & lZielzeile & ": Datum " & rawDate & " ist ein Sonntag. Setze Spalte U auf " & (rawDate - 3)
            Else
                wsZiel.Cells(lZielzeile, 21).Value = rawDate - 1
                Debug.Print "Zeile " & lZielzeile & ": Setze Spalte U auf " & (rawDate - 1)
            End If
            
            ' Nächste freie Zeile für neuen Vorgang
            dictStartZeilen(strZielblattName) = lZielzeile + 1
            
            ' Header abhängige Werte (aus Spalte L)
            upperHeader = UCase(Trim(CStr(rawHeader)))
            If dictHeaders(strZielblattName).Exists(upperHeader) Then
                zielSpalte = dictHeaders(strZielblattName)(upperHeader)
                rawValL = Trim(CStr(wsData.Cells(i, 12).Value))
                
                ' Werte konvertieren
                Select Case UCase(rawValL)
                    Case "JA"
                        rawValL = "j"
                    Case "NEIN"
                        rawValL = "n"
                    Case "N/A"
                        rawValL = ""   ' Leer lassen
                    Case "TEILWEISE"
                        rawValL = "t"
                End Select
                
                ' Wert in die Zielspalte einfügen
                wsZiel.Cells(lZielzeile, zielSpalte).Value = rawValL
                Debug.Print "Setze Wert '" & rawValL & "' in Spalte " & zielSpalte & " für Zeile " & lZielzeile
            Else
                Debug.Print "Header '" & upperHeader & "' nicht gefunden in Zielblatt '" & strZielblattName & "'"
            End If
            
    NächsterDatensatz:
        Next i
    
    wbData.Close False
    MsgBox "Import abgeschlossen!"
    Exit Sub
    
Fehlerbehandlung:
    MsgBox "Ein Fehler ist aufgetreten: " & Err.Description, vbCritical
    On Error Resume Next
    wbData.Close False
End Sub

' Hilfsfunktion zur Suche der Kalenderwoche in mehreren Spalten
Function FindKWInColumns(ws As Worksheet, currentKW As String, searchColumns As Variant) As Range
    Dim col As Variant
    Dim rngCell As Range
    Dim cellValue As String
    Dim searchKWNoSpace As String
    Dim cellKWNoSpace As String
    
    ' Entferne Leerzeichen aus currentKW
    searchKWNoSpace = Replace(currentKW, " ", "")
    
    For Each col In searchColumns
        ' Bestimmen der letzten verwendeten Zeile in der aktuellen Spalte
        Dim lastRow As Long
        lastRow = ws.Cells(ws.Rows.Count, col).End(xlUp).Row
        
        For Each rngCell In ws.Range(col & "1:" & col & lastRow)
            cellValue = Trim(UCase(rngCell.Value))
            cellKWNoSpace = Replace(cellValue, " ", "")
            
            ' Debugging-Ausgabe für jede Zelle
            Debug.Print "Suche in " & rngCell.Address & ": '" & cellValue & "', ohne Leerzeichen: '" & cellKWNoSpace & "'"
            
            If cellKWNoSpace = UCase(Replace(currentKW, " ", "")) Then
                Debug.Print "Gefunden in " & rngCell.Address & ": '" & cellValue & "'"
                Set FindKWInColumns = rngCell
                Exit Function
            End If
        Next rngCell
    Next col
    
    Set FindKWInColumns = Nothing
End Function

Function GetKalenderwoche(datum As Date) As Long
    ' ISO 8601 Kalenderwoche
    ' Montag ist der erste Tag der Woche
    ' Die erste Woche des Jahres ist diejenige, die mindestens vier Tage enthält
    GetKalenderwoche = DatePart("ww", datum, vbMonday, vbFirstFourDays)
End Function
