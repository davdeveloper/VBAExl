Option Explicit

Sub ImportiereRohdatenFinal()
    Dim wbDash As Workbook
    Dim wbData As Workbook
    Dim wsZuweisung As Worksheet
    Dim wsZiel As Worksheet
    Dim wsData As Worksheet
    Dim wsKategorien As Worksheet
    Dim rngFound As Range
    
    Dim lLetzteZeileZuweisung As Long
    Dim lLetzteZeileData As Long
    Dim lLetzteZeileKatA As Long
    
    Dim i As Long, j As Long
    
    Dim rawKey As String
    Dim rawVorgang As String
    Dim rawHeader As String
    Dim rawValue As Variant
    Dim strZielblattName As String
    Dim lZielzeile As Long
    
    Dim dictHeaders As Object
    Dim dictStartZeilen As Object
    Dim dictKategorien As Object
    
    Dim upperHeader As String
    Dim zielSpalte As Long
    Dim englischerText As String
    Dim deutscherText As String
    
    Dim englVal As Variant
    Dim rawValL As Variant
    Dim rawDate As Variant ' Verwenden Sie Variant für Flexibilität
    
    ' Setzen der Arbeitsmappen und Arbeitsblätter
    Set wbDash = ThisWorkbook
    Set wsZuweisung = wbDash.Worksheets("Zuweisung")
    Set wsKategorien = wbDash.Worksheets("Kategorien")
    
    ' Rohdaten öffnen (Pfad anpassen!)
    On Error GoTo Fehlerbehandlung
    Set wbData = Workbooks.Open("C:\Pfad\zu\Leaptree_Data.xlsx") ' Passen Sie den Pfad an
    On Error GoTo 0
    Set wsData = wbData.Worksheets(1)
    
    ' Letzte Zeilen ermitteln
    lLetzteZeileZuweisung = wsZuweisung.Cells(wsZuweisung.Rows.Count, 2).End(xlUp).Row
    lLetzteZeileData = wsData.Cells(wsData.Rows.Count, 1).End(xlUp).Row
    
    ' Dictionaries initialisieren
    Set dictHeaders = CreateObject("Scripting.Dictionary")
    Set dictStartZeilen = CreateObject("Scripting.Dictionary")
    Set dictKategorien = CreateObject("Scripting.Dictionary")
    
    ' Kategorien einlesen (Englisch -> Deutsch)
    lLetzteZeileKatA = wsKategorien.Cells(wsKategorien.Rows.Count, 1).End(xlUp).Row
    For i = 2 To lLetzteZeileKatA
        If Not IsEmpty(wsKategorien.Cells(i, 1)) Then
            englischerText = Trim(CStr(wsKategorien.Cells(i, 1).Value))
            deutscherText = Trim(CStr(wsKategorien.Cells(i, 2).Value))
            If Not dictKategorien.Exists(englischerText) Then
                dictKategorien(englischerText) = deutscherText
            End If
        End If
    Next i
    
    ' Datenimport starten
    For i = 2 To lLetzteZeileData
        rawKey = Trim(CStr(wsData.Cells(i, 1).Value))      ' Rohdaten Spalte A - Schlüssel
        rawVorgang = Trim(CStr(wsData.Cells(i, 2).Value))  ' Rohdaten Spalte B - Vorgangsnummer
        rawHeader = Trim(CStr(wsData.Cells(i, 10).Value))  ' Rohdaten Spalte J - Headername
        
        ' Schlüssel in Zuweisung suchen
        Set rngFound = wsZuweisung.Columns(2).Find(What:=rawKey, LookAt:=xlWhole, LookIn:=xlValues, MatchCase:=False)
        If Not rngFound Is Nothing Then
            strZielblattName = Trim(CStr(rngFound.Offset(0, 1).Value)) ' Zielblatt aus Spalte C in Zuweisung
            
            ' Zielblatt referenzieren
            On Error Resume Next
            Set wsZiel = wbDash.Worksheets(strZielblattName)
            On Error GoTo 0
            
            If wsZiel Is Nothing Then
                ' Zielblatt nicht gefunden, nächsten Datensatz
                GoTo NächsterDatensatz
            End If
            
            ' Headers des Zielblatts einlesen, falls noch nicht geschehen
            If Not dictHeaders.Exists(strZielblattName) Then
                Set dictHeaders(strZielblattName) = CreateObject("Scripting.Dictionary")
                For j = 3 To 17 ' Spalten C bis Q
                    If Not IsEmpty(wsZiel.Cells(12, j).Value) Then
                        upperHeader = UCase(Trim(CStr(wsZiel.Cells(12, j).Value)))
                        If Not dictHeaders(strZielblattName).Exists(upperHeader) Then
                            dictHeaders(strZielblattName)(upperHeader) = j
                        End If
                    End If
                Next j
            End If
            
            ' Einmalig pro Blatt Startzeile bestimmen
            Dim startZeile As Long
            If Not dictStartZeilen.Exists(strZielblattName) Then
                ' Neue Logik zur Bestimmung der Startzeile basierend auf rawDate
                rawDate = wsData.Cells(i, 4).Value ' Rohdaten Spalte D
                
                If IsDate(rawDate) Then
                    rawDate = CDate(rawDate)
                Else
                    rawDate = Date ' Fallback auf aktuelles Datum, falls ungültig
                End If
                
                startZeile = FindeStartzeileBasierendAufKW(wsZiel, rawDate)
                If startZeile = 0 Then
                    ' Falls keine passende Startzeile gefunden wurde, überspringen
                    GoTo NächsterDatensatz
                End If
                dictStartZeilen(strZielblattName) = startZeile
            Else
                startZeile = dictStartZeilen(strZielblattName)
            End If
            
            ' Vorgangszeile suchen
            Set rngFound = wsZiel.Columns(1).Find(What:=rawVorgang, LookAt:=xlWhole, LookIn:=xlValues, MatchCase:=False)
            If rngFound Is Nothing Then
                ' Vorgang noch nicht vorhanden, neuen Eintrag an startZeile
                lZielzeile = startZeile
                
                ' Übersetzung der Spalte C (Englisch -> Deutsch)
                englVal = Trim(CStr(wsData.Cells(i, 3).Value))
                If dictKategorien.Exists(englVal) Then
                    wsZiel.Cells(lZielzeile, 2).Value = dictKategorien(englVal) ' Deutscher Text
                Else
                    wsZiel.Cells(lZielzeile, 2).Value = englVal ' Unverändert, falls kein Mapping
                End If
                
                ' Vorgangsnummer in Spalte A
                wsZiel.Cells(lZielzeile, 1).Value = rawVorgang
                
                ' Spalte V (22) = Rohdaten Spalte D (4)
                wsZiel.Cells(lZielzeile, 22).Value = rawDate
                
                ' Spalte W (23) = Rohdaten Spalte E (5)
                wsZiel.Cells(lZielzeile, 23).Value = wsData.Cells(i, 5).Value
                
                ' Spalte U (21):
                ' Ausgehend von rawDate:
                ' Immer einen Tag zurück, außer wenn dieser Tag ein Sonntag ist, dann Freitag vorher
                If Weekday(rawDate - 1, vbMonday) = vbSunday Then
                    wsZiel.Cells(lZielzeile, 21).Value = rawDate - 3
                Else
                    wsZiel.Cells(lZielzeile, 21).Value = rawDate - 1
                End If
                
                ' Startzeile für nächsten neuen Vorgang erhöhen
                dictStartZeilen(strZielblattName) = startZeile + 1
            Else
                ' Vorgangsnummer existiert schon, Zeile festlegen
                lZielzeile = rngFound.Row
            End If
            
            ' Header abhängige Werte (aus Spalte L)
            upperHeader = UCase(Trim(CStr(rawHeader)))
            If dictHeaders(strZielblattName).Exists(upperHeader) Then
                zielSpalte = dictHeaders(strZielblattName)(upperHeader)
                rawValL = Trim(CStr(wsData.Cells(i, 12).Value))
                
                ' Werte konvertieren
                Select Case UCase(rawValL)
                    Case "JA"
                        rawValL = "j"
                    Case "NEIN"
                        rawValL = "n"
                    Case "N/A"
                        rawValL = ""   ' Leer lassen
                    Case "TEILWEISE"
                        rawValL = "t"
                    Case Else
                        rawValL = rawValL ' Unverändert lassen, falls andere Werte vorhanden sind
                End Select
                
                ' Wert in die Zielspalte einfügen
                wsZiel.Cells(lZielzeile, zielSpalte).Value = rawValL
            End If
            
        End If
NächsterDatensatz:
        Set wsZiel = Nothing
    Next i
    
    ' Rohdaten-Workbook schließen, ohne zu speichern
    wbData.Close False
    MsgBox "Import abgeschlossen!"
    Exit Sub
    
Fehlerbehandlung:
    MsgBox "Ein Fehler ist aufgetreten: " & Err.Description, vbCritical
    On Error Resume Next
    wbData.Close False
End Sub

Function FindeStartzeileBasierendAufKW(ws As Worksheet, rawDate As Date) As Long
    Dim adjustedDate As Date
    Dim currentKW As String
    Dim rngKW As Range
    Dim startCheckCell As Range
    Dim lCheckRow As Long
    
    ' Wenn das Datum ein Montag ist, nimm den vergangenen Freitag
    If Weekday(rawDate, vbMonday) = vbMonday Then
        adjustedDate = rawDate - 3
    Else
        adjustedDate = rawDate - 1
    End If
    
    ' Kalenderwoche berechnen mit führender Null
    currentKW = "KW " & Format(GetKalenderwoche(adjustedDate), "00")
    
    ' Nach "KW xx" in Spalte A suchen
    Set rngKW = ws.Columns(1).Find(What:=currentKW, LookAt:=xlWhole, LookIn:=xlValues, MatchCase:=False)
    If rngKW Is Nothing Then
        MsgBox currentKW & " nicht in Spalte A des Arbeitsblatts '" & ws.Name & "' gefunden.", vbExclamation
        FindeStartzeileBasierendAufKW = 0
        Exit Function
    End If
    
    ' Zeile anzeigen, wo "KW xx" gefunden wurde
    MsgBox "Aktuelle Kalenderwoche '" & currentKW & "' gefunden in Zelle: " & rngKW.Address, vbInformation
    
    ' 3 Zeilen runter von der KW-Zelle
    Set startCheckCell = rngKW.Offset(3, 0)
    lCheckRow = startCheckCell.Row
    
    ' Prüfen, ob die Zelle leer ist. Wenn nicht, +30 Zeilen weiterspringen
    Do While ws.Cells(lCheckRow, 1).Value <> ""
        lCheckRow = lCheckRow + 30
    Loop
    
    ' Startzeile zurückgeben
    FindeStartzeileBasierendAufKW = lCheckRow
End Function

Function GetKalenderwoche(datum As Date) As Long
    ' ISO 8601 Kalenderwoche
    ' Montag ist der erste Tag der Woche
    ' Die erste Woche des Jahres ist diejenige, die mindestens vier Tage enthält
    
    GetKalenderwoche = DatePart("ww", datum, vbMonday, vbFirstFourDays)
End Function
